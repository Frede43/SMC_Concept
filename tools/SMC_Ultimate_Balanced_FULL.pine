// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)
// ¬© LuxAlgo
// Modifications & Dashboard by Antigravity (SMC Ultimate Fusion)

//@version=5
strategy('SMC Ultra [Pro]', 'SMC Ultra [Pro]', overlay = true, initial_capital = 10000, default_qty_type = strategy.fixed, currency = currency.USD, commission_type = strategy.commission.percent, commission_value = 0.003, slippage=1, max_labels_count = 500, max_lines_count = 500, max_boxes_count = 500, calc_on_every_tick = true)

//---------------------------------------------------------------------------------------------------------------------}
// üéØ BALANCED ULTRA MODE - PHILOSOPHY
//---------------------------------------------------------------------------------------------------------------------{
// Conservative        : 13 filtres ‚Üí 1.75 trades/an ‚Üí PF 6.58 ‚Üí Profit 1.54%/an
// Balanced (Actuel)   : 8 filtres  ‚Üí 3.75 trades/an ‚Üí PF ‚àû    ‚Üí Profit 22%/an (TROP PEU DE TRADES)
// Balanced ULTRA      : 6 filtres  ‚Üí 30-50 trades/an ‚Üí PF 2.5+ ‚Üí Profit 15-25%/an (OBJECTIF)
//
// ‚úÖ FILTRES GARD√âS : Daily Trend, P/D Zones (65%), BOS (0.4), Volume (0.5), Killzone, Candle
// ‚ùå FILTRES D√âSACTIV√âS : MTF, SMT, Sweep, ADR (trop stricts)
//---------------------------------------------------------------------------------------------------------------------}

//---------------------------------------------------------------------------------------------------------------------}
// LUXALGO CONSTANTS & STRINGS & INPUTS
//---------------------------------------------------------------------------------------------------------------------{
BULLISH_LEG                     = 1
BEARISH_LEG                     = 0

BULLISH                         = +1
BEARISH                         = -1

GREEN                           = #089981
RED                             = #F23645
BLUE                            = #2157f3
GRAY                            = #878b94
MONO_BULLISH                    = #b2b5be
MONO_BEARISH                    = #5d606b

HISTORICAL                      = 'Historical'
PRESENT                         = 'Present'

COLORED                         = 'Colored'
MONOCHROME                      = 'Monochrome'

ALL                             = 'All'
BOS                             = 'BOS'
CHOCH                           = 'CHoCH'

TINY                            = size.tiny
SMALL                           = size.small
NORMAL                          = size.normal

ATR                             = 'Atr'
RANGE                           = 'Cumulative Mean Range'

CLOSE                           = 'Close'
HIGHLOW                         = 'High/Low'

SOLID                           = '‚éØ‚éØ‚éØ'
DASHED                          = '----'
DOTTED                          = '¬∑¬∑¬∑¬∑'

SMART_GROUP                     = 'Smart Money Concepts'
INTERNAL_GROUP                  = 'Real Time Internal Structure'
SWING_GROUP                     = 'Real Time Swing Structure'
BLOCKS_GROUP                    = 'Order Blocks'
EQUAL_GROUP                     = 'EQH/EQL'
GAPS_GROUP                      = 'Fair Value Gaps'
LEVELS_GROUP                    = 'Highs & Lows MTF'
ZONES_GROUP                     = 'Premium & Discount Zones'

// üé® BALANCED MODE SETTINGS
grp_signals = "üéØ TRADE SIGNALS (BALANCED MODE)"
show_signals = input.bool(true, "Show Buy/Sell Signals", group=grp_signals, tooltip="Show entries when price mitigates an OB/FVG and aligns with trend")
sig_size     = input.string(size.small, "Signal Label Size", options=[size.tiny, size.small, size.normal], group=grp_signals)

// üÜï BALANCED FILTERS (D√©sactiv√©s par d√©faut)
use_mtf_filter = input.bool(false, "‚ùå MTF Confirmation (DISABLED)", group=grp_signals, tooltip="BALANCED: D√©sactiv√© pour plus de trades")
htf_tf         = input.timeframe('240', "HTF Timeframe", group=grp_signals)

use_rm_labels  = input.bool(true, "Show SL/TP Labels", group=grp_signals, tooltip="Calculate and show Stop Loss and Take Profit levels")
risk_per_trade = input.float(1.0, "Risk Per Trade (%)", minval=0.1, step=0.1, group=grp_signals, tooltip="Percent of equity to risk on each trade based on Stop Loss distance")
rr_ratio       = input.float(3.0, "Institutional RR Target", minval=0.1, step=0.1, group=grp_signals, tooltip="Targeting a consistent 3.0 RR")
sl_padding_atr = input.float(1.0, "SL Safety (ATR)", minval=0.0, step=0.1, group=grp_signals, tooltip="Safety buffer: 1.0 ATR")
use_be         = input.bool(true, "Use Break-Even", group=grp_signals, tooltip="Move SL to entry after 1.1 RR")
be_target      = input.float(1.1, "BE Trigger (RR)", minval=0.1, step=0.1, group=grp_signals, tooltip="Sync with Partial TP for Risk-Free Trade")
use_partial_tp = input.bool(true, "Use Partial Take Profit", group=grp_signals, tooltip="Close 30% at 1.1 RR")
partial_rr     = input.float(1.1, "Partial TP (RR)", minval=0.5, step=0.1, group=grp_signals, tooltip="Fast secure at 1.1 RR")

use_vol_filter = input.bool(true, "‚úÖ Volume Filter (ULTRA)", group=grp_signals, tooltip="ULTRA: Seuil ajust√© √† 0.7x")
vol_mult       = input.float(0.7, "Volume Multiplier", minval=0.4, step=0.1, group=grp_signals, tooltip="ULTRA: 0.7 (Filtre le bruit)")

use_bos_filter = input.bool(true, "‚úÖ BOS Strength (ULTRA)", group=grp_signals, tooltip="ULTRA: Seuil ajust√© √† 0.5 ATR")
bos_threshold  = input.float(0.5, "BOS Strength Threshold", minval=0.1, step=0.1, group=grp_signals, tooltip="ULTRA: 0.5 (Filtre les fausses cassures)")

// üÜï REALISM & FLEXIBILITY
mitigation_buffer_atr = input.float(0.1, "Mitigation Buffer (ATR)", minval=0.0, step=0.05, group=grp_signals, tooltip="Allows entry if price misses the zone by this amount (Fixes rigitidy/front-running)")


use_smt_filter = input.bool(false, "‚ùå SMT Divergence (DISABLED)", group=grp_signals, tooltip="BALANCED: D√©sactiv√©, pas pertinent pour toutes les paires")
smt_ticker     = input.symbol("FX:GBPUSD", "SMT Correlated Ticker", group=grp_signals)

// üÜï TOP-DOWN FILTERS (Weekly ‚Üí Daily ‚Üí Intraday)
use_weekly_filter = input.bool(true, "‚úÖ Weekly Trend Filter (TOP-DOWN)", group=grp_signals, tooltip="RECOMMENDED: Trade only in the direction of the Weekly trend for higher probability")
use_daily_align = input.bool(true, "‚úÖ Daily Trend Alignment", group=grp_signals, tooltip="Confirm Weekly trend with Daily structure")
use_internal_trend = input.bool(true, "‚úÖ Trade Internal Trend", group=grp_signals, tooltip="ULTRA: Trade based on Internal Structure (Faster) instead of Swing")
use_pd_filter   = input.bool(true, "‚úÖ Premium/Discount (ULTRA)", group=grp_signals, tooltip="ULTRA: Seuil assoupli √† 60%")
use_sweep_conf  = input.bool(false, "‚ùå Liquidity Sweep (DISABLED)", group=grp_signals, tooltip="BALANCED: D√©sactiv√©")
use_adr_filter  = input.bool(false, "‚ùå ADR Exhaustion (DISABLED)", group=grp_signals, tooltip="ULTRA: D√©sactiv√© pour ne pas bloquer les runs")
max_daily_loss  = input.int(2, "Max Daily Trades Lost", minval=1, group=grp_signals, tooltip="Stop trading for the day after X losing trades")
max_drawdown_pct= input.float(3.0, "Max Daily Drawdown (%)", minval=0.1, step=0.1, group=grp_signals, tooltip="Stop trading if today's loss exceeds X% of capital")

grp_dash    = "üöÄ PRO DASHBOARD"
show_dash   = input.bool(true, "Show Institutional Dashboard", group=grp_dash)
show_sig_dash = input.bool(true, "Show BIG Signal Alert", group=grp_dash, tooltip="Displays a large box with the current signal status")
dash_size   = input.string(size.small, "Dashboard Size", options=[size.tiny, size.small, size.normal], group=grp_dash)

grp_visual  = "üé® VISUAL ENHANCEMENTS"
show_sweeps = input.bool(true, "Show Liquidity Sweeps (X)", group=grp_visual, tooltip="Marks candle wicks that sweep a level but close inside")
show_pd_bg  = input.bool(true, "Show Premium/Discount Background", group=grp_visual, tooltip="Red/Green background based on current dealing range")
c_prem_fill = input.color(color.new(#FF5252, 92), "Premium Zone Fill", group=grp_visual)
c_disc_fill = input.color(color.new(#00E676, 92), "Discount Zone Fill", group=grp_visual)
show_pdh_pdl= input.bool(true, "Show PDH / PDL Labels", group=grp_visual)
show_weekly_levels = input.bool(true, "Show Weekly High/Low", group=grp_visual, tooltip="Display Weekly pivots as major liquidity zones")
clean_mode = input.bool(false, "Clean Mode (Less Clutter)", group=grp_visual, tooltip="Hides some elements on lower timeframes to reduce visual noise")

grp_breaker = "üí• BREAKER BLOCKS (SMC PRO)"
show_breakers = input.bool(true, "Show Breaker Blocks", group=grp_breaker, tooltip="Mitigated OB that gets broken = Very strong reversal signal")
breaker_bull_color = input.color(color.new(#00BCD4, 75), "Bullish Breaker", group=grp_breaker)
breaker_bear_color = input.color(color.new(#FF6D00, 75), "Bearish Breaker", group=grp_breaker)

grp_killzone = "‚è∞ ICT KILLZONES"
show_killzones = input.bool(true, "Show ICT Killzones", group=grp_killzone, tooltip="London (02-05h), NY AM (08:30-11h), NY PM (13:30-16h) NY Time")
kz_london_color = input.color(color.new(#2196F3, 90), "London KZ", group=grp_killzone)
kz_nyam_color = input.color(color.new(#FFC107, 90), "NY AM KZ", group=grp_killzone)
kz_nypm_color = input.color(color.new(#9C27B0, 90), "NY PM KZ", group=grp_killzone)
kz_asian_color = input.color(color.new(#00BCD4, 90), "Asian KZ", group=grp_killzone)

grp_advanced = "‚öôÔ∏è ADVANCED & UX"
strict_mode   = input.bool(true, "Strict Non-Repainting Mode", group=grp_advanced, tooltip="Waits for X bars before confirming structure (Less repainting, more lag)")
strict_delay  = input.int(1, "Confirmation Delay (Bars)", minval=1, group=grp_advanced)
show_targets  = input.bool(true, "Show Projected Target Lines", group=grp_advanced)

// LUXALGO INPUTS
modeInput                       = input.string( PRESENT,    'Mode',                     group = SMART_GROUP,    options = [HISTORICAL, PRESENT])
styleInput                      = input.string( COLORED,    'Style',                    group = SMART_GROUP,    options = [COLORED, MONOCHROME])
showTrendInput                  = input(        false,      'Color Candles',            group = SMART_GROUP)

showInternalsInput              = input(        false,      'Show Internal Structure',  group = INTERNAL_GROUP) // ‚ö° CLEAN: False par d√©faut
showInternalBullInput           = input.string( ALL,        'Bullish Structure',        group = INTERNAL_GROUP, inline = 'ibull', options = [ALL,BOS,CHOCH])
internalBullColorInput          = input(        GREEN,      '',                         group = INTERNAL_GROUP, inline = 'ibull')
showInternalBearInput           = input.string( ALL,        'Bearish Structure' ,       group = INTERNAL_GROUP, inline = 'ibear', options = [ALL,BOS,CHOCH])
internalBearColorInput          = input(        RED,        '',                         group = INTERNAL_GROUP, inline = 'ibear')
internalFilterConfluenceInput   = input(        false,      'Confluence Filter',        group = INTERNAL_GROUP)
internalStructureSize           = input.string( TINY,       'Internal Label Size',      group = INTERNAL_GROUP, options = [TINY,SMALL,NORMAL])

showStructureInput              = input(        true,       'Show Swing Structure',     group = SWING_GROUP)
showSwingBullInput              = input.string( ALL,        'Bullish Structure',        group = SWING_GROUP,    inline = 'bull',    options = [ALL,BOS,CHOCH])
swingBullColorInput             = input(        GREEN,      '',                         group = SWING_GROUP,    inline = 'bull')
showSwingBearInput              = input.string( ALL,        'Bearish Structure',        group = SWING_GROUP,    inline = 'bear',    options = [ALL,BOS,CHOCH])
swingBearColorInput             = input(        RED,        '',                         group = SWING_GROUP,    inline = 'bear')
swingStructureSize              = input.string( SMALL,      'Swing Label Size',         group = SWING_GROUP,    options = [TINY,SMALL,NORMAL])
showSwingsInput                 = input(        false,      'Show Swings Points',       group = SWING_GROUP,    inline = 'swings')
swingsLengthInput               = input.int(    20,         '',                         group = SWING_GROUP,    minval = 10,                inline = 'swings')
showHighLowSwingsInput          = input(        true,       'Show Strong/Weak High/Low',group = SWING_GROUP)

showInternalOrderBlocksInput    = input(        true,       'Internal Order Blocks' ,   group = BLOCKS_GROUP,   inline = 'iob')
internalOrderBlocksSizeInput    = input.int(    10,         '',                         group = BLOCKS_GROUP,   minval = 1, maxval = 20,                    inline = 'iob')
showSwingOrderBlocksInput       = input(        true,       'Swing Order Blocks',       group = BLOCKS_GROUP,   inline = 'ob')
swingOrderBlocksSizeInput       = input.int(    10,         '',                         group = BLOCKS_GROUP,   minval = 1, maxval = 20,                    inline = 'ob') 
orderBlockFilterInput           = input.string( 'Atr',      'Order Block Filter',       group = BLOCKS_GROUP,   options = [ATR, RANGE])
orderBlockMitigationInput       = input.string( HIGHLOW,    'Order Block Mitigation',   group = BLOCKS_GROUP,   options = [CLOSE,HIGHLOW])
internalBullishOrderBlockColor  = input.color(color.new(#1848cc, 80), 'Internal Bullish OB',    group = BLOCKS_GROUP)
internalBearishOrderBlockColor  = input.color(color.new(#b22833, 80), 'Internal Bearish OB',    group = BLOCKS_GROUP)
swingBullishOrderBlockColor     = input.color(color.new(#1848cc, 80), 'Bullish OB',             group = BLOCKS_GROUP)
swingBearishOrderBlockColor     = input.color(color.new(#b22833, 80), 'Bearish OB',             group = BLOCKS_GROUP)


showEqualHighsLowsInput         = input(        true,       'Equal High/Low',           group = EQUAL_GROUP)
equalHighsLowsLengthInput       = input.int(    3,          'Bars Confirmation',        group = EQUAL_GROUP,    minval = 1)
equalHighsLowsThresholdInput    = input.float(  0.1,        'Threshold',                group = EQUAL_GROUP,    minval = 0, maxval = 0.5, step = 0.1)
equalHighsLowsSizeInput         = input.string( TINY,       'Label Size',               group = EQUAL_GROUP,    options = [TINY,SMALL,NORMAL])

showFairValueGapsInput          = input(        true,       'Fair Value Gaps',          group = GAPS_GROUP) // Enabled by default for Pro user
fairValueGapsThresholdInput     = input(        true,       'Auto Threshold',           group = GAPS_GROUP)
fairValueGapsTimeframeInput     = input.timeframe('',       'Timeframe',                group = GAPS_GROUP)
fairValueGapsBullColorInput     = input.color(color.new(#00bcd4, 85), 'Bullish FVG (Cyan)', group = GAPS_GROUP)
fairValueGapsBearColorInput     = input.color(color.new(#ff9800, 85), 'Bearish FVG (Orange)', group = GAPS_GROUP)

fairValueGapsExtendInput        = input.int(    1,          'Extend FVG',               group = GAPS_GROUP,     minval = 0)

showDailyLevelsInput            = input(        false,      'Daily',    group = LEVELS_GROUP,   inline = 'daily')
dailyLevelsStyleInput           = input.string( SOLID,      '',         group = LEVELS_GROUP,   inline = 'daily',   options = [SOLID,DASHED,DOTTED])
dailyLevelsColorInput           = input(        BLUE,       '',         group = LEVELS_GROUP,   inline = 'daily')
showWeeklyLevelsInput           = input(        false,      'Weekly',   group = LEVELS_GROUP,   inline = 'weekly')
weeklyLevelsStyleInput          = input.string( SOLID,      '',         group = LEVELS_GROUP,   inline = 'weekly',  options = [SOLID,DASHED,DOTTED])
weeklyLevelsColorInput          = input(        BLUE,       '',         group = LEVELS_GROUP,   inline = 'weekly')
showMonthlyLevelsInput          = input(        false,      'Monthly',   group = LEVELS_GROUP,   inline = 'monthly')
monthlyLevelsStyleInput         = input.string( SOLID,      '',         group = LEVELS_GROUP,   inline = 'monthly', options = [SOLID,DASHED,DOTTED])
monthlyLevelsColorInput         = input(        BLUE,       '',         group = LEVELS_GROUP,   inline = 'monthly')
// GLOBAL CALCULATIONS (FOR DASHBOARD & FUSION)
//---------------------------------------------------------------------------------------------------------------------{
// Daily Data for Dashboard
// üõ°Ô∏è NO-LOOKAHEAD DAILY DATA (Utilise la bougie d'hier termin√©e)
[d_open, d_high, d_low, d_close] = request.security(syminfo.tickerid, "D", [open[1], high[1], low[1], close[1]], lookahead=barmerge.lookahead_off)
d_sma20        = request.security(syminfo.tickerid, "D", ta.sma(close, 20)[1], lookahead=barmerge.lookahead_off)
d_ema13        = request.security(syminfo.tickerid, "D", ta.ema(close, 13)[1], lookahead=barmerge.lookahead_off)
is_forex       = syminfo.type == "forex"
is_gold        = str.contains(syminfo.ticker, "XAU") or str.contains(syminfo.ticker, "GOLD")

// ‚ö° GOLD OPTIMIZED TREND
// Gold reverses faster than Forex. We use EMA 8 for Gold to catch trends earlier.
d_trend_val = is_gold ? request.security(syminfo.tickerid, "D", ta.ema(close, 8)[1], lookahead=barmerge.lookahead_off) : (is_forex ? d_ema13 : d_sma20)


d_trend_txt = d_close > d_trend_val ? "BULLISH" : "BEARISH"
d_trend_col = d_close > d_trend_val ? GREEN : RED

// üÜï ADR CALCULATIONS (GLOBAL NO-LOOKAHEAD)
d_adr_20       = request.security(syminfo.tickerid, "D", ta.atr(20)[1], lookahead=barmerge.lookahead_off)

// üõ°Ô∏è Live Daily Range Tracking (No Lookahead)
var float d_high_live = na
var float d_low_live  = na
if ta.change(time("D")) != 0
    d_high_live := high
    d_low_live  := low
else
    d_high_live := math.max(high, d_high_live)
    d_low_live  := math.min(low, d_low_live)

// üõ°Ô∏è Trade Tracking (Global)
var float trade_sl     = na
var float trade_ent    = na
var bool  partial_done  = false
var float last_bos_strength = 0.0
var int last_bos_time = 0

//---------------------------------------------------------------------------------------------------------------------}
// DATA STRUCTURES
//---------------------------------------------------------------------------------------------------------------------{
type alerts
    bool internalBullishBOS         = false
    bool internalBearishBOS         = false
    bool internalBullishCHoCH       = false
    bool internalBearishCHoCH       = false
    bool swingBullishBOS            = false
    bool swingBearishBOS            = false
    bool swingBullishCHoCH          = false
    bool swingBearishCHoCH          = false
    bool internalBullishOrderBlock  = false
    bool internalBearishOrderBlock  = false
    bool swingBullishOrderBlock     = false
    bool swingBearishOrderBlock     = false
    bool equalHighs                 = false
    bool equalLows                  = false
    bool bullishFairValueGap        = false
    bool bearishFairValueGap        = false

type trailingExtremes
    float top
    float bottom
    int barTime
    int barIndex
    int lastTopTime
    int lastBottomTime

type fairValueGap
    float top
    float bottom
    int bias
    box topBox
    box bottomBox

type trend
    int bias    

type equalDisplay
    line l_ine      = na
    label l_abel    = na

type pivot
    float currentLevel
    float lastLevel
    bool crossed
    int barTime     = time
    int barIndex    = bar_index

type orderBlock
    float barHigh
    float barLow
    int barTime    
    int bias

type breakerBlock
    float barHigh
    float barLow
    int barTime
    int bias           // BULLISH ou BEARISH
    bool isActive
    int origin_type    // 0=mitigated OB, 1=failed structure

var pivot swingHigh                 = pivot.new(na,na,false)
var pivot swingLow                  = pivot.new(na,na,false)
var pivot internalHigh              = pivot.new(na,na,false)
var pivot internalLow               = pivot.new(na,na,false)
var pivot equalHigh                 = pivot.new(na,na,false)
var pivot equalLow                  = pivot.new(na,na,false)
var trend swingTrend                = trend.new(0)
var trend internalTrend             = trend.new(0)
var equalDisplay equalHighDisplay   = equalDisplay.new()
var equalDisplay equalLowDisplay    = equalDisplay.new()
var array<fairValueGap> fairValueGaps = array.new<fairValueGap>()
var array<float> parsedHighs        = array.new<float>()
var array<float> parsedLows         = array.new<float>()
var array<float> highs              = array.new<float>()
var array<float> lows               = array.new<float>()
var array<int> times                = array.new<int>()
var trailingExtremes trailing       = trailingExtremes.new()
var array<orderBlock> swingOrderBlocks      = array.new<orderBlock>()
var array<orderBlock> internalOrderBlocks   = array.new<orderBlock>()
var array<box> swingOrderBlocksBoxes        = array.new<box>()
var array<box> internalOrderBlocksBoxes     = array.new<box>()
var array<breakerBlock> breakerBlocks       = array.new<breakerBlock>()
var array<box> breakerBlocksBoxes           = array.new<box>()
var swingBullishColor               = styleInput == MONOCHROME ? MONO_BULLISH : swingBullColorInput
var swingBearishColor               = styleInput == MONOCHROME ? MONO_BEARISH : swingBearColorInput
var fairValueGapBullishColor        = styleInput == MONOCHROME ? color.new(MONO_BULLISH,70) : fairValueGapsBullColorInput
var fairValueGapBearishColor        = styleInput == MONOCHROME ? color.new(MONO_BEARISH,70) : fairValueGapsBearColorInput
// var premiumZoneColor                = styleInput == MONOCHROME ? MONO_BEARISH : premiumZoneColorInput
// var discountZoneColor               = styleInput == MONOCHROME ? MONO_BULLISH : discountZoneColorInput 
varip int currentBarIndex           = bar_index
varip int lastBarIndex              = bar_index
alerts currentAlerts                = alerts.new()
var initialTime                     = time

// üÜï MTF & SMT CALCULATIONS (NO REPAINTING FIX)
// We use lookahead_off to ensure we only use Closed Data from Higher Timeframes
htf_bias = request.security(syminfo.tickerid, htf_tf, swingTrend.bias, lookahead=barmerge.lookahead_off)
smt_bias = use_smt_filter ? request.security(smt_ticker, timeframe.period, swingTrend.bias, lookahead=barmerge.lookahead_off) : 0

// üÜï WEEKLY ANALYSIS (TOP-DOWN APPROACH - MACRO CONTEXT)
// Provides the big picture trend and key levels for all timeframes
// This is the foundation of institutional trading: Macro ‚Üí Micro
// NOTE: Must be declared AFTER swingTrend, swingHigh, swingLow are initialized
w_trend = request.security(syminfo.tickerid, "W", swingTrend.bias, lookahead=barmerge.lookahead_off)
w_high = request.security(syminfo.tickerid, "W", swingHigh.currentLevel, lookahead=barmerge.lookahead_off)
w_low = request.security(syminfo.tickerid, "W", swingLow.currentLevel, lookahead=barmerge.lookahead_off)
w_close = request.security(syminfo.tickerid, "W", close[1], lookahead=barmerge.lookahead_off)

// Weekly Trend Text & Color
w_trend_txt = w_trend == BULLISH ? "BULLISH" : w_trend == BEARISH ? "BEARISH" : "NEUTRAL"
w_trend_col = w_trend == BULLISH ? GREEN : w_trend == BEARISH ? RED : GRAY

// Weekly Range (for context and volatility assessment)
w_range = not na(w_high) and not na(w_low) ? w_high - w_low : 0
w_range_pct = w_low > 0 and not na(w_range) ? (w_range / w_low) * 100 : 0


if barstate.isfirst
    if showSwingOrderBlocksInput
        for index = 1 to swingOrderBlocksSizeInput
            swingOrderBlocksBoxes.push(box.new(na,na,na,na,xloc = xloc.bar_time,extend = extend.right))
    if showInternalOrderBlocksInput
        for index = 1 to internalOrderBlocksSizeInput
            internalOrderBlocksBoxes.push(box.new(na,na,na,na,xloc = xloc.bar_time,extend = extend.right))
    if show_breakers
        for index = 1 to 5  // Max 5 Breakers actifs
            breakerBlocksBoxes.push(box.new(na,na,na,na,xloc = xloc.bar_time,extend = extend.right))

bearishOrderBlockMitigationSource   = orderBlockMitigationInput == CLOSE ? close : high
bullishOrderBlockMitigationSource   = orderBlockMitigationInput == CLOSE ? close : low
atrMeasure                          = ta.atr(200)
atr_val_14_global                   = ta.atr(14)
volatilityMeasure                   = orderBlockFilterInput == ATR ? atrMeasure : ta.cum(ta.tr)/bar_index

highVolatilityBar                   = (high - low) >= (2 * volatilityMeasure)
parsedHigh                          = highVolatilityBar ? low : high
parsedLow                           = highVolatilityBar ? high : low

parsedHighs.push(parsedHigh)
parsedLows.push(parsedLow)
highs.push(high)
lows.push(low)
times.push(time)

//---------------------------------------------------------------------------------------------------------------------}
// LUXALGO FUNCTIONS
//---------------------------------------------------------------------------------------------------------------------{
leg(int size) =>
    var leg     = 0    
    newLegHigh  = high[size] > ta.highest( size)
    newLegLow   = low[size]  < ta.lowest(  size)
    if newLegHigh
        leg := BEARISH_LEG
    else if newLegLow
        leg := BULLISH_LEG
    leg

startOfNewLeg(int leg)      => ta.change(leg) != 0
startOfBearishLeg(int leg)  => ta.change(leg) == -1
startOfBullishLeg(int leg)  => ta.change(leg) == +1

drawLabel(int labelTime, float labelPrice, string tag, color labelColor, string labelStyle) =>    
    var label l_abel = na
    if modeInput == PRESENT
        l_abel.delete()
    l_abel := label.new(chart.point.new(labelTime,na,labelPrice),tag,xloc.bar_time,color=color(na),textcolor=labelColor,style = labelStyle,size = size.small)

drawEqualHighLow(pivot p_ivot, float level, int size, bool equalHigh) =>
    equalDisplay e_qualDisplay = equalHigh ? equalHighDisplay : equalLowDisplay
    string tag          = 'EQL'
    color equalColor    = swingBullishColor
    string labelStyle   = label.style_label_up
    if equalHigh
        tag         := 'EQH'
        equalColor  := swingBearishColor
        labelStyle  := label.style_label_down
    if modeInput == PRESENT
        line.delete(    e_qualDisplay.l_ine)
        label.delete(   e_qualDisplay.l_abel)
    e_qualDisplay.l_ine     := line.new(chart.point.new(p_ivot.barTime,na,p_ivot.currentLevel), chart.point.new(time[size],na,level), xloc = xloc.bar_time, color = equalColor, style = line.style_dotted)
    labelPosition           = math.round(0.5*(p_ivot.barIndex + bar_index - size))
    e_qualDisplay.l_abel    := label.new(chart.point.new(na,labelPosition,level), tag, xloc.bar_index, color = color(na), textcolor = equalColor, style = labelStyle, size = equalHighsLowsSizeInput)

getCurrentStructure(int size,bool equalHighLow = false, bool internal = false) =>        
    currentLeg              = leg(size)
    newPivot                = startOfNewLeg(currentLeg)
    pivotLow                = startOfBullishLeg(currentLeg)
    pivotHigh               = startOfBearishLeg(currentLeg)

    if newPivot
        if pivotLow
            pivot p_ivot    = equalHighLow ? equalLow : internal ? internalLow : swingLow    
            if equalHighLow and math.abs(p_ivot.currentLevel - low[size]) < equalHighsLowsThresholdInput * atrMeasure                
                drawEqualHighLow(p_ivot, low[size], size, false)
                currentAlerts.equalLows := true
            p_ivot.lastLevel    := p_ivot.currentLevel
            p_ivot.currentLevel := low[size]
            p_ivot.crossed      := false
            p_ivot.barTime      := time[size]
            p_ivot.barIndex     := bar_index[size]
            if not equalHighLow and not internal
                trailing.bottom         := p_ivot.currentLevel
                trailing.barTime        := p_ivot.barTime
                trailing.barIndex       := p_ivot.barIndex
                trailing.lastBottomTime := p_ivot.barTime
            if showSwingsInput and not internal and not equalHighLow
                drawLabel(time[size], p_ivot.currentLevel, p_ivot.currentLevel < p_ivot.lastLevel ? 'LL' : 'HL', swingBullishColor, label.style_label_up)            
        else
            pivot p_ivot = equalHighLow ? equalHigh : internal ? internalHigh : swingHigh
            if equalHighLow and math.abs(p_ivot.currentLevel - high[size]) < equalHighsLowsThresholdInput * atrMeasure
                drawEqualHighLow(p_ivot,high[size],size,true)
                currentAlerts.equalHighs := true               
            p_ivot.lastLevel    := p_ivot.currentLevel
            p_ivot.currentLevel := high[size]
            p_ivot.crossed      := false
            p_ivot.barTime      := time[size]
            p_ivot.barIndex     := bar_index[size]
            if not equalHighLow and not internal
                trailing.top            := p_ivot.currentLevel
                trailing.barTime        := p_ivot.barTime
                trailing.barIndex       := p_ivot.barIndex
                trailing.lastTopTime    := p_ivot.barTime
            if showSwingsInput and not internal and not equalHighLow
                drawLabel(time[size], p_ivot.currentLevel, p_ivot.currentLevel > p_ivot.lastLevel ? 'HH' : 'LH', swingBearishColor, label.style_label_down)
                
drawStructure(pivot p_ivot, string tag, color structureColor, string lineStyle, string labelStyle, string labelSize) =>    
    var line l_ine      = line.new(na,na,na,na,xloc = xloc.bar_time)
    var label l_abel    = label.new(na,na)
    if modeInput == PRESENT
        l_ine.delete()
        l_abel.delete()
    l_ine   := line.new(chart.point.new(p_ivot.barTime,na,p_ivot.currentLevel), chart.point.new(time,na,p_ivot.currentLevel), xloc.bar_time, color=structureColor, style=lineStyle)
    l_abel  := label.new(chart.point.new(na,math.round(0.5*(p_ivot.barIndex+bar_index)),p_ivot.currentLevel), tag, xloc.bar_index, color=color(na), textcolor=structureColor, style=labelStyle, size = labelSize)

deleteOrderBlocks(bool internal = false) =>
    array<orderBlock> orderBlocks = internal ? internalOrderBlocks : swingOrderBlocks
    for [index,eachOrderBlock] in orderBlocks
        bool crossedOderBlock = false
        if bearishOrderBlockMitigationSource > eachOrderBlock.barHigh and eachOrderBlock.bias == BEARISH
            crossedOderBlock := true
            if internal
                currentAlerts.internalBearishOrderBlock := true
            else
                currentAlerts.swingBearishOrderBlock    := true
        else if bullishOrderBlockMitigationSource < eachOrderBlock.barLow and eachOrderBlock.bias == BULLISH
            crossedOderBlock := true
            if internal
                currentAlerts.internalBullishOrderBlock := true
            else
                currentAlerts.swingBullishOrderBlock    := true
        if crossedOderBlock                    
            orderBlocks.remove(index)            

storeOrdeBlock(pivot p_ivot,bool internal = false,int bias) =>
    if (not internal and showSwingOrderBlocksInput) or (internal and showInternalOrderBlocksInput)
        array<float> a_rray = na
        int parsedIndex = na
        if bias == BEARISH
            a_rray      := parsedHighs.slice(p_ivot.barIndex,bar_index)
            parsedIndex := p_ivot.barIndex + a_rray.indexof(a_rray.max())  
        else
            a_rray      := parsedLows.slice(p_ivot.barIndex,bar_index)
            parsedIndex := p_ivot.barIndex + a_rray.indexof(a_rray.min())                        
        orderBlock o_rderBlock          = orderBlock.new(parsedHighs.get(parsedIndex), parsedLows.get(parsedIndex), times.get(parsedIndex),bias)
        array<orderBlock> orderBlocks   = internal ? internalOrderBlocks : swingOrderBlocks
        if orderBlocks.size() >= 100
            orderBlocks.pop()
        orderBlocks.unshift(o_rderBlock)

drawOrderBlocks(bool internal = false) =>        
    array<orderBlock> orderBlocks = internal ? internalOrderBlocks : swingOrderBlocks
    orderBlocksSize = orderBlocks.size()
    if orderBlocksSize > 0        
        maxOrderBlocks                      = internal ? internalOrderBlocksSizeInput : swingOrderBlocksSizeInput
        array<orderBlock> parsedOrdeBlocks  = orderBlocks.slice(0, math.min(maxOrderBlocks,orderBlocksSize))
        array<box> b_oxes                   = internal ? internalOrderBlocksBoxes : swingOrderBlocksBoxes        
        for [index,eachOrderBlock] in parsedOrdeBlocks
            // Define Base Colors (Institutional)
            baseColor = eachOrderBlock.bias == BEARISH ? #D63D3D : #00B5AD
            
            // Professional Style: High Transparency Background + Solid Border
            bg_col     = color.new(baseColor, 90) // 90% Transparent
            border_col = color.new(baseColor, 30) // Solid Border
            
            box b_ox        = b_oxes.get(index)
            b_ox.set_top_left_point(    chart.point.new(eachOrderBlock.barTime,na,eachOrderBlock.barHigh))
            b_ox.set_bottom_right_point(chart.point.new(last_bar_time,na,eachOrderBlock.barLow))        
            b_ox.set_border_color(      border_col)
            b_ox.set_bgcolor(           bg_col)
            b_ox.set_border_width(1)
            b_ox.set_border_style(line.style_solid)

displayStructure(bool internal = false) =>
    var bullishBar = true
    var bearishBar = true
    if internalFilterConfluenceInput
        bullishBar := high - math.max(close, open) > math.min(close, open - low)
        bearishBar := high - math.max(close, open) < math.min(close, open - low)
    pivot p_ivot    = internal ? internalHigh : swingHigh
    trend t_rend    = internal ? internalTrend : swingTrend
    lineStyle       = internal ? line.style_dashed : line.style_solid
    labelSize       = internal ? internalStructureSize : swingStructureSize
    extraCondition  = internal ? internalHigh.currentLevel != swingHigh.currentLevel and bullishBar : true
    strict_check    = not strict_mode or (bar_index - p_ivot.barIndex >= strict_delay)
    bullishColor    = styleInput == MONOCHROME ? MONO_BULLISH : internal ? internalBullColorInput : swingBullColorInput
    if ta.crossover(close,p_ivot.currentLevel) and not p_ivot.crossed and extraCondition and strict_check
        string tag = t_rend.bias == BEARISH ? CHOCH : BOS
        if internal
            currentAlerts.internalBullishCHoCH  := tag == CHOCH
            currentAlerts.internalBullishBOS    := tag == BOS
        else
            currentAlerts.swingBullishCHoCH     := tag == CHOCH
            currentAlerts.swingBullishBOS       := tag == BOS
        p_ivot.crossed  := true
        t_rend.bias     := BULLISH
        displayCondition = internal ? showInternalsInput and (showInternalBullInput == ALL or (showInternalBullInput == BOS and tag != CHOCH) or (showInternalBullInput == CHOCH and tag == CHOCH)) : showStructureInput and (showSwingBullInput == ALL or (showSwingBullInput == BOS and tag != CHOCH) or (showSwingBullInput == CHOCH and tag == CHOCH))
        if displayCondition                        
            drawStructure(p_ivot,tag,bullishColor,lineStyle,label.style_label_down,labelSize)
        if (internal and showInternalOrderBlocksInput) or (not internal and showSwingOrderBlocksInput)
            storeOrdeBlock(p_ivot,internal,BULLISH)
    p_ivot          := internal ? internalLow : swingLow    
    extraCondition  := internal ? internalLow.currentLevel != swingLow.currentLevel and bearishBar : true
    strict_check    := not strict_mode or (bar_index - p_ivot.barIndex >= strict_delay)
    bearishColor    = styleInput == MONOCHROME ? MONO_BEARISH : internal ? internalBearColorInput : swingBearColorInput
    if ta.crossunder(close,p_ivot.currentLevel) and not p_ivot.crossed and extraCondition and strict_check
        string tag = t_rend.bias == BULLISH ? CHOCH : BOS
        if internal
            currentAlerts.internalBearishCHoCH  := tag == CHOCH
            currentAlerts.internalBearishBOS    := tag == BOS
        else
            currentAlerts.swingBearishCHoCH     := tag == CHOCH
            currentAlerts.swingBearishBOS       := tag == BOS
        p_ivot.crossed := true
        t_rend.bias := BEARISH
        displayCondition = internal ? showInternalsInput and (showInternalBearInput == ALL or (showInternalBearInput == BOS and tag != CHOCH) or (showInternalBearInput == CHOCH and tag == CHOCH)) : showStructureInput and (showSwingBearInput == ALL or (showSwingBearInput == BOS and tag != CHOCH) or (showSwingBearInput == CHOCH and tag == CHOCH))
        if displayCondition                        
            drawStructure(p_ivot,tag,bearishColor,lineStyle,label.style_label_up,labelSize)
        if (internal and showInternalOrderBlocksInput) or (not internal and showSwingOrderBlocksInput)
            storeOrdeBlock(p_ivot,internal,BEARISH)

fairValueGapBox(leftTime,rightTime,topPrice,bottomPrice,boxColor) => box.new(chart.point.new(leftTime,na,topPrice),chart.point.new(rightTime + fairValueGapsExtendInput * (time-time[1]),na,bottomPrice), xloc=xloc.bar_time, border_color = boxColor, bgcolor = boxColor)

deleteFairValueGaps() =>
    for [index,eachFairValueGap] in fairValueGaps
        if (low < eachFairValueGap.bottom and eachFairValueGap.bias == BULLISH) or (high > eachFairValueGap.top and eachFairValueGap.bias == BEARISH)
            eachFairValueGap.topBox.delete()
            eachFairValueGap.bottomBox.delete()
            fairValueGaps.remove(index)
    
drawFairValueGaps() => 
    // FIX REPAINTING: lookahead_off ensures we don't see the future of the higher timeframe bar
    [lastClose, lastOpen, lastTime, currentHigh, currentLow, currentTime, last2High, last2Low] = request.security(syminfo.tickerid, fairValueGapsTimeframeInput, [close[1], open[1], time[1], high[0], low[0], time[0], high[2], low[2]], lookahead = barmerge.lookahead_off)

    barDeltaPercent     = (lastClose - lastOpen) / (lastOpen * 100)
    newTimeframe        = timeframe.change(fairValueGapsTimeframeInput)
    threshold           = fairValueGapsThresholdInput ? ta.cum(math.abs(newTimeframe ? barDeltaPercent : 0)) / bar_index * 2 : 0
    bullishFairValueGap = currentLow > last2High and lastClose > last2High and barDeltaPercent > threshold and newTimeframe
    bearishFairValueGap = currentHigh < last2Low and lastClose < last2Low and -barDeltaPercent > threshold and newTimeframe
    if bullishFairValueGap
        currentAlerts.bullishFairValueGap := true
        fairValueGaps.unshift(fairValueGap.new(currentLow,last2High,BULLISH,fairValueGapBox(lastTime,currentTime,currentLow,math.avg(currentLow,last2High),fairValueGapBullishColor),fairValueGapBox(lastTime,currentTime,math.avg(currentLow,last2High),last2High,fairValueGapBullishColor)))
    if bearishFairValueGap
        currentAlerts.bearishFairValueGap := true
        fairValueGaps.unshift(fairValueGap.new(currentHigh,last2Low,BEARISH,fairValueGapBox(lastTime,currentTime,currentHigh,math.avg(currentHigh,last2Low),fairValueGapBearishColor),fairValueGapBox(lastTime,currentTime,math.avg(currentHigh,last2Low),last2Low,fairValueGapBearishColor)))

getStyle(string style) =>
    switch style
        SOLID => line.style_solid
        DASHED => line.style_dashed
        DOTTED => line.style_dotted

higherTimeframe(string timeframe) => timeframe.in_seconds() > timeframe.in_seconds(timeframe)

updateTrailingExtremes() =>
    trailing.top            := math.max(high,trailing.top)
    trailing.lastTopTime    := trailing.top == high ? time : trailing.lastTopTime
    trailing.bottom         := math.min(low,trailing.bottom)
    trailing.lastBottomTime := trailing.bottom == low ? time : trailing.lastBottomTime

//---------------------------------------------------------------------------------------------------------------------}
drawLevels(string timeframe, bool sameTimeframe, string style, color levelColor) =>
    [topLevel, bottomLevel, leftTime, rightTime] = request.security(syminfo.tickerid, timeframe, [high[1], low[1], time[1], time],lookahead = barmerge.lookahead_on)

    float parsedTop         = sameTimeframe ? high : topLevel
    float parsedBottom      = sameTimeframe ? low : bottomLevel    

    int parsedLeftTime      = sameTimeframe ? time : leftTime
    int parsedRightTime     = sameTimeframe ? time : rightTime

    int parsedTopTime       = time
    int parsedBottomTime    = time

    if not sameTimeframe
        int leftIndex               = times.binary_search_rightmost(parsedLeftTime)
        int rightIndex              = times.binary_search_rightmost(parsedRightTime)

        array<int> timeArray        = times.slice(leftIndex,rightIndex)
        array<float> topArray       = highs.slice(leftIndex,rightIndex)
        array<float> bottomArray    = lows.slice(leftIndex,rightIndex)

        parsedTopTime               := timeArray.size() > 0 ? timeArray.get(topArray.indexof(topArray.max())) : initialTime
        parsedBottomTime            := timeArray.size() > 0 ? timeArray.get(bottomArray.indexof(bottomArray.min())) : initialTime

    var line topLine        = line.new(na, na, na, na, xloc = xloc.bar_time, color = levelColor, style = getStyle(style))
    var line bottomLine     = line.new(na, na, na, na, xloc = xloc.bar_time, color = levelColor, style = getStyle(style))
    var label topLabel      = label.new(na, na, xloc = xloc.bar_time, text = str.format('P{0}H',timeframe), color=color(na), textcolor = levelColor, size = size.small, style = label.style_label_left)
    var label bottomLabel   = label.new(na, na, xloc = xloc.bar_time, text = str.format('P{0}L',timeframe), color=color(na), textcolor = levelColor, size = size.small, style = label.style_label_left)

    base_time = time
    
    topLine.set_first_point(    chart.point.new(parsedTopTime,na,parsedTop))
    topLine.set_second_point(   chart.point.new(base_time + 20 * (time-time[1]),na,parsedTop))   
    topLabel.set_point(         chart.point.new(base_time + 20 * (time-time[1]),na,parsedTop))

    bottomLine.set_first_point( chart.point.new(parsedBottomTime,na,parsedBottom))    
    bottomLine.set_second_point(chart.point.new(base_time + 20 * (time-time[1]),na,parsedBottom))
    bottomLabel.set_point(      chart.point.new(base_time + 20 * (time-time[1]),na,parsedBottom))

drawHighLowSwings() =>
    var line topLine        = line.new(na, na, na, na, color = swingBearishColor, xloc = xloc.bar_time)
    var line bottomLine     = line.new(na, na, na, na, color = swingBullishColor, xloc = xloc.bar_time)
    var label topLabel      = label.new(na, na, color=color(na), textcolor = swingBearishColor, xloc = xloc.bar_time, style = label.style_label_down, size = size.tiny)
    var label bottomLabel   = label.new(na, na, color=color(na), textcolor = swingBullishColor, xloc = xloc.bar_time, style = label.style_label_up, size = size.tiny)

    rightTimeBar            = time + 20 * (time - time[1])

    topLine.set_first_point(    chart.point.new(trailing.lastTopTime, na, trailing.top))
    topLine.set_second_point(   chart.point.new(rightTimeBar, na, trailing.top))
    topLabel.set_point(         chart.point.new(rightTimeBar, na, trailing.top))
    topLabel.set_text(          swingTrend.bias == BEARISH ? 'Strong High' : 'Weak High')

    bottomLine.set_first_point( chart.point.new(trailing.lastBottomTime, na, trailing.bottom))
    bottomLine.set_second_point(chart.point.new(rightTimeBar, na, trailing.bottom))
    bottomLabel.set_point(      chart.point.new(rightTimeBar, na, trailing.bottom))
    bottomLabel.set_text(       swingTrend.bias == BULLISH ? 'Strong Low' : 'Weak Low')

// üÜï ADDED FEATURES: SWEEPS, PDH/PDL, DASHBOARD, ZONES
//---------------------------------------------------------------------------------------------------------------------{

// 1. LIQUIDITY SWEEPS (Simple Layer)
// We use a separate simple pivot logic for sweeps to be non-intrusive
if show_sweeps
    // Lookback for local sweeps
    s_sw = 5 
    ph_s = ta.pivothigh(high, s_sw, s_sw)
    pl_s = ta.pivotlow(low, s_sw, s_sw)
    var float v_ph_s = na
    var float v_pl_s = na
    if not na(ph_s)
        v_ph_s := ph_s
    if not na(pl_s)
        v_pl_s := pl_s
        
    // Detect Sweep
    if not na(v_ph_s) and high > v_ph_s and high[1] <= v_ph_s and close < v_ph_s
        label.new(bar_index, high, "x", color=color.new(RED, 100), textcolor=RED, style=label.style_none, size=size.normal)
    if not na(v_pl_s) and low < v_pl_s and low[1] >= v_pl_s and close > v_pl_s
        label.new(bar_index, low, "x", color=color.new(GREEN, 100), textcolor=GREEN, style=label.style_none, size=size.normal)

// 2. PDH / PDL LABELS (Simple visual)
if show_pdh_pdl
    var line pdh_line = na
    var line pdl_line = na
    var label pdh_lbl = na
    var label pdl_lbl = na
    line.delete(pdh_line)
    line.delete(pdl_line)
    label.delete(pdh_lbl)
    label.delete(pdl_lbl)
    
    // Draw
    pdh_line := line.new(bar_index - 50, d_high, bar_index + 10, d_high, color=color.new(GRAY, 50), style=line.style_dashed)
    pdl_line := line.new(bar_index - 50, d_low,  bar_index + 10, d_low,  color=color.new(GRAY, 50), style=line.style_dashed)
    
    pdh_lbl := label.new(bar_index + 10, d_high, "PDH", style=label.style_none, textcolor=GRAY, size=size.small, textalign=text.align_left)
    pdl_lbl := label.new(bar_index + 10, d_low,  "PDL", style=label.style_none, textcolor=GRAY, size=size.small, textalign=text.align_left)

// 3. VISUAL PREMIUM / DISCOUNT ZONES (Red/Green Background)
// We rely on LuxAlgo's 'trailing' variable which tracks the current leg Structure
var box box_premium = na
var box box_discount = na
var line line_50 = na

if show_pd_bg and trailing.top > trailing.bottom
    mid = (trailing.top + trailing.bottom) / 2
    box.delete(box_premium)
    box.delete(box_discount)
    line.delete(line_50)
    
    box_premium := box.new(bar_index - 10, trailing.top, bar_index + 10, mid, border_color=na, bgcolor=c_prem_fill)
    box_discount := box.new(bar_index - 10, mid, bar_index + 10, trailing.bottom, border_color=na, bgcolor=c_disc_fill)
    line_50 := line.new(bar_index - 10, mid, bar_index + 10, mid, color=color.gray, style=line.style_dashed)

// 4. WEEKLY HIGH/LOW LEVELS (Major Liquidity Zones)
// These are the institutional targets - where big money takes profit
if show_weekly_levels and not na(w_high) and not na(w_low)
    var line w_high_line = na
    var line w_low_line = na
    var label w_high_lbl = na
    var label w_low_lbl = na
    
    // Delete previous lines/labels
    line.delete(w_high_line)
    line.delete(w_low_line)
    label.delete(w_high_lbl)
    label.delete(w_low_lbl)
    
    // Draw Weekly High (Major Resistance)
    w_high_line := line.new(bar_index - 100, w_high, bar_index + 20, w_high, color=color.new(color.red, 60), width=2, style=line.style_dashed)
    
    // Draw Weekly Low (Major Support)
    w_low_line := line.new(bar_index - 100, w_low, bar_index + 20, w_low, color=color.new(color.green, 60), width=2, style=line.style_dashed)
    
    // Label Weekly High
    w_high_lbl := label.new(bar_index + 20, w_high, "W HIGH", style=label.style_none, textcolor=color.new(color.red, 20), size=size.small, textalign=text.align_left)
    
    // Label Weekly Low
    w_low_lbl := label.new(bar_index + 20, w_low, "W LOW", style=label.style_none, textcolor=color.new(color.green, 20), size=size.small, textalign=text.align_left)

//---------------------------------------------------------------------------------------------------------------------}
// üí• BREAKER BLOCKS DETECTION (100% SMC)
//---------------------------------------------------------------------------------------------------------------------{

// D√©tection des Breakers: OB qui a √©t√© mitig√© puis recass√© dans la direction oppos√©e
detectBreakers() =>
    if show_breakers
        // V√©rifier les OB qui ont √©t√© mitig√©s

        // Variable de blocage si perte quotidienne trop grande (Protection)
        // loss_confirm calculated above
        // V√©rifier les OB qui ont √©t√© mitig√©s
        for [idx, ob] in swingOrderBlocks
            // Bullish Breaker: ancien Bearish OB qui est maintenant cass√© vers le haut
            if ob.bias == BEARISH and close > ob.barHigh
                // V√©rifier qu'il n'existe pas d√©j√†
                breaker_exists = false
                for breaker in breakerBlocks
                    if breaker.barTime == ob.barTime
                        breaker_exists := true
                        break
                
                if not breaker_exists and breakerBlocks.size() < 5
                    new_breaker = breakerBlock.new(ob.barHigh, ob.barLow, ob.barTime, BULLISH, true, 0)
                    breakerBlocks.unshift(new_breaker)
                    if breakerBlocks.size() > 5
                        breakerBlocks.pop()
            
            // Bearish Breaker: ancien Bullish OB qui est maintenant cass√© vers le bas
            else if ob.bias == BULLISH and close < ob.barLow
                breaker_exists = false
                for breaker in breakerBlocks
                    if breaker.barTime == ob.barTime
                        breaker_exists := true
                        break
                
                if not breaker_exists and breakerBlocks.size() < 5
                    new_breaker = breakerBlock.new(ob.barHigh, ob.barLow, ob.barTime, BEARISH, true, 0)
                    breakerBlocks.unshift(new_breaker)
                    if breakerBlocks.size() > 5
                        breakerBlocks.pop()

// Afficher les Breaker Blocks
drawBreakers() =>
    if show_breakers and breakerBlocks.size() > 0
        for [index, breaker] in breakerBlocks
            if index < breakerBlocksBoxes.size()
                breaker_color = breaker.bias == BULLISH ? breaker_bull_color : breaker_bear_color
                box b_ox = breakerBlocksBoxes.get(index)
                b_ox.set_top_left_point(chart.point.new(breaker.barTime, na, breaker.barHigh))
                b_ox.set_bottom_right_point(chart.point.new(last_bar_time, na, breaker.barLow))
                b_ox.set_border_color(color.new(breaker_color, 50))
                b_ox.set_bgcolor(breaker_color)
                b_ox.set_border_width(2)

// Calculer BOS Strength pour le dashboard
calculateBOSStrength() =>
    var float strength = 0.0
    var int last_update = 0
    
    // Calculer l'ATR en dehors du bloc conditionnel pour coh√©rence
    atr_val = ta.atr(14)
    
    // Calculer la force bas√©e sur la distance entre swing high et low
    if swingHigh.currentLevel > 0 and swingLow.currentLevel > 0
        range_pts = math.abs(swingHigh.currentLevel - swingLow.currentLevel)
        strength := atr_val > 0 ? (range_pts / atr_val) : 0
    
    strength

//---------------------------------------------------------------------------------------------------------------------}
// ‚è∞ ICT KILLZONES (100% SMC)
//---------------------------------------------------------------------------------------------------------------------{

// D√©tection des Killzones ICT (NY Time)
// London: 02:00-05:00 NY / NY AM: 08:30-11:00 NY / NY PM: 13:30-16:00 NY
getKillzone() =>
    // Obtenir l'heure actuelle en NY time (GMT-5 standard, GMT-4 DST)
    // Note: TradingView utilise l'exchange timezone, ajuster si n√©cessaire
    h = hour(time, "America/New_York")
    m = minute(time, "America/New_York")
    
    // London Killzone: 02:00-05:00 NY
    is_london = h >= 2 and h < 5
    
    // NY AM Killzone: 08:30-11:00 NY
    is_ny_am = (h == 8 and m >= 30) or (h >= 9 and h < 11)
    
    // NY PM Killzone: 13:30-16:00 NY (aussi appel√© "Power of 3")
    is_ny_pm = (h == 13 and m >= 30) or (h >= 14 and h < 16)
    
    kz_type = is_london ? "LONDON" : is_ny_am ? "NY_AM" : is_ny_pm ? "NY_PM" : "NONE"
    kz_color = is_london ? kz_london_color : is_ny_am ? kz_nyam_color : is_ny_pm ? kz_nypm_color : na
    
    [kz_type, kz_color, is_london or is_ny_am or is_ny_pm]

// üÜï ASIAN RANGE CALCULATION (00:00 - 06:00 NY Time)
is_asian = hour(time, "America/New_York") >= 0 and hour(time, "America/New_York") < 6
var float asian_h = na
var float asian_l = na

if is_asian
    if not is_asian[1]
        asian_h := high
        asian_l := low
    else
        asian_h := math.max(high, asian_h)
        asian_l := math.min(low, asian_l)

[kz_name_raw, kz_col_raw, is_kz_raw] = getKillzone()
is_crypto = syminfo.type == "crypto" or syminfo.type == "bitcoin"
is_jpy    = str.contains(syminfo.ticker, "JPY")

// Logic pour le Dashboard et le Trading
is_kz = is_kz_raw or (is_jpy and is_asian) or is_crypto
kz_name = (is_jpy or is_crypto) and is_asian and not is_kz_raw ? "ASIAN" : kz_name_raw
kz_col = (is_jpy or is_crypto) and is_asian and not is_kz_raw ? kz_asian_color : kz_col_raw

bgcolor(show_killzones and is_kz ? kz_col : na, title="Killzone Highlight")

if show_killzones
    // Label au d√©but de chaque killzone
    var label kz_label = na
    if is_kz and not is_kz[1]
        label.delete(kz_label)
        kz_label := label.new(bar_index, high, kz_name, style=label.style_label_down, color=color.new(kz_col, 70), textcolor=color.white, size=size.small)

//---------------------------------------------------------------------------------------------------------------------}
// üõ°Ô∏è NO-LOOKAHEAD Daily Loss Protection (Global Scope)
var int   daily_losses     = 0
var float start_day_equity = strategy.equity
if ta.change(time("D")) != 0
    daily_losses     := 0
    start_day_equity := strategy.equity

if ta.change(strategy.losstrades) > 0
    daily_losses := daily_losses + 1

daily_drawdown_pct = not na(start_day_equity) and start_day_equity > 0 ? ((start_day_equity - strategy.equity) / start_day_equity) * 100 : 0
loss_confirm       = daily_losses < max_daily_loss and daily_drawdown_pct < max_drawdown_pct

// 4. INSTITUTIONAL DASHBOARD (TOP-DOWN APPROACH)
var table dash = table.new(position.top_right, 2, 10, bgcolor=color.new(#131722, 10), border_color=color.new(GRAY, 80))

// Calculer BOS Strength √† chaque tick pour coh√©rence
bos_str = calculateBOSStrength()

if show_dash and barstate.islast
    // Header
    table.cell(dash, 0, 0, "SMC FUSION", text_color=color.white, bgcolor=color.black, text_size=dash_size)
    table.cell(dash, 1, 0, "INSTITUTIONAL", text_color=color.silver, bgcolor=color.black, text_size=dash_size)
    
    // Structure (LuxAlgo Logic)
    // swingTrend.bias: 1=BULLISH, -1=BEARISH
    st_txt = swingTrend.bias == BULLISH ? "BULLISH" : "BEARISH"
    st_col = swingTrend.bias == BULLISH ? GREEN : RED
    table.cell(dash, 0, 1, "Structure (Swing)", text_color=color.silver, text_halign=text.align_left, text_size=dash_size)
    table.cell(dash, 1, 1, st_txt, text_color=st_col, bgcolor=color.new(st_col, 90), text_size=dash_size)
    
    // üÜï WEEKLY TREND (TOP-DOWN - Most Important)
    table.cell(dash, 0, 2, "Trend (Weekly)", text_color=color.silver, text_halign=text.align_left, text_size=dash_size)
    table.cell(dash, 1, 2, w_trend_txt, text_color=w_trend_col, bgcolor=color.new(w_trend_col, 90), text_size=dash_size)
    
    // Trend (Daily)
    table.cell(dash, 0, 3, "Trend (Daily)", text_color=color.silver, text_halign=text.align_left, text_size=dash_size)
    table.cell(dash, 1, 3, d_trend_txt, text_color=d_trend_col, bgcolor=color.new(d_trend_col, 90), text_size=dash_size)
    
    // BOS Strength (100% SMC - remplace RSI)
    bos_txt = str.tostring(bos_str, "#.#") + " ATR"
    bos_c = bos_str > 2.0 ? GREEN : bos_str > 1.0 ? color.orange : RED
    table.cell(dash, 0, 4, "BOS Strength", text_color=color.silver, text_halign=text.align_left, text_size=dash_size)
    table.cell(dash, 1, 4, bos_txt, text_color=bos_c, bgcolor=color.new(bos_c, 90), text_size=dash_size)
    
    // üÜï ADR Exhaustion Check (100% SMC)
    float d_range_cur = (d_high_live - d_low_live)
    adr_exhausted = (d_high_live - d_low_live) > (d_adr_20 * (is_forex ? 1.4 : 2.0))
    float adr_pct = d_adr_20 > 0 ? (d_range_cur / d_adr_20) * 100 : 0
    
    adr_txt = str.tostring(adr_pct, "#.0") + "%"
    adr_col = adr_pct >= 200 ? RED : adr_pct >= 150 ? color.orange : GREEN
    
    table.cell(dash, 0, 5, "ADR Exhaustion", text_color=color.silver, text_halign=text.align_left, text_size=dash_size)
    table.cell(dash, 1, 5, adr_txt, text_color=adr_col, bgcolor=color.new(adr_col, 90), text_size=dash_size)

    // Killzone Active (100% SMC)
    kz_display = is_kz ? kz_name : "NONE"
    kz_display_col = is_kz ? color.yellow : GRAY
    
    // Killzone status (Use the synced logic)
    table.cell(dash, 0, 6, "Killzone", text_color=color.silver, text_halign=text.align_left, text_size=dash_size)
    table.cell(dash, 1, 6, kz_name, text_color=kz_col, bgcolor=color.new(kz_col, 90), text_size=dash_size)
    
    // Pricing
    mid_price = (trailing.top + trailing.bottom) / 2
    pr_txt = close > mid_price ? "Premium" : "Discount"
    pr_col = close > mid_price ? RED : GREEN
    table.cell(dash, 0, 7, "Pricing", text_color=color.silver, text_halign=text.align_left, text_size=dash_size)
    table.cell(dash, 1, 7, pr_txt, text_color=pr_col, bgcolor=color.new(pr_col, 90), text_size=dash_size)
    
    // Asian Range
    asian_txt = na(asian_h) ? "WAITING" : str.tostring(asian_h, format.mintick) + " / " + str.tostring(asian_l, format.mintick)
    table.cell(dash, 0, 8, "Asian High/Low", text_color=color.silver, text_halign=text.align_left, text_size=dash_size)
    table.cell(dash, 1, 8, asian_txt, text_color=color.yellow, text_size=dash_size)
    
    // üÜï Weekly Range (Volatility Context)
    w_range_txt = str.tostring(w_range_pct, "#.##") + "%"
    table.cell(dash, 0, 9, "Weekly Range", text_color=color.silver, text_halign=text.align_left, text_size=dash_size)
    table.cell(dash, 1, 9, w_range_txt, text_color=color.aqua, text_size=dash_size)

//---------------------------------------------------------------------------------------------------------------------}

//---------------------------------------------------------------------------------------------------------------------}
//---------------------------------------------------------------------------------------------------------------------}
// üöÄ LIVE TRADE MONITOR (DYNAMIC DASHBOARD)
displaySignalDash() =>
    if show_sig_dash
        var table sig_tab = table.new(position.bottom_right, 1, 1)
        string txt    = "üîç SEARCHING SETUP..."
        color  bg_col = color.new(color.gray, 20)
        
        if strategy.position_size != 0
            bool is_long = strategy.position_size > 0
            txt := (is_long ? "ÔøΩ LONG ACTIVE ÔøΩ" : "üíÄ SHORT ACTIVE üíÄ")
            bg_col := is_long ? color.new(#00ff68, 10) : color.new(#ff0008, 10)
            
            // LIVE STATS (Calcul dynamique)
            risk = math.abs(trade_ent - trade_sl)
            tp   = is_long ? trade_ent + (risk * rr_ratio) : trade_ent - (risk * rr_ratio)
            
            float pips_diff = (close - trade_ent) / (syminfo.mintick * 10)
            bool  is_profit = is_long ? close > trade_ent : close < trade_ent
            float cur_rr    = risk != 0 ? math.abs(close - trade_ent) / risk : 0
            
            txt := txt + "\nENT: " + str.tostring(trade_ent, format.mintick)
            txt := txt + "\nSL: " + str.tostring(trade_sl, format.mintick)
            txt := txt + "\nTP: " + str.tostring(tp, format.mintick)
            txt := txt + "\nPROFIT: " + (is_profit ? "üü¢ +" : "üî¥ -") + str.tostring(cur_rr, "#.##") + " RR"
            txt := txt + "\nPIPS: " + (is_profit ? "+" : "") + str.tostring(is_long ? pips_diff : -pips_diff, "#.#")
            
            if partial_done
                txt := txt + "\n‚úÖ PARTIAL TP SECURED"
        else
            txt := "üîç WAITING SETUP\n" + (swingTrend.bias == BULLISH ? "BIAS: BULLISH üü¢" : "BIAS: BEARISH üî¥")
            bg_col := color.new(color.black, 40)
        
        table.cell(sig_tab, 0, 0, txt, text_color=color.white, bgcolor=bg_col, text_size=size.small)

// üéØ SIGNAL GENERATION (VISUALIZE BOT ENTRIES)
//---------------------------------------------------------------------------------------------------------------------{
// Cette section simule la logique d'entr√©e du bot pour l'affichage visuel
// Condition: Tendance Swing align√©e + Mitigation Zone (OB/FVG) + Bougie de rejet

var int last_signal_dir = 0 // 1=Buy, -1=Sell

checkSignals() =>
    int new_dir = last_signal_dir
    float sig_sl = na
    float sig_ent = na
    
    // Extract ATR to avoid warnings
    // Extract ATR from global scope to avoid warnings and ensure consistency
    atr_val_14 = atr_val_14_global

    
    // 0. ADR Exhaustion Check (Corrected logic)
    today_range = high - low // Placeholder simplified for bar range
    adr_val = d_adr_20 
    // Simplified ADR: today's high/low vs average
    adr_confirm = not use_adr_filter or adr_val == 0 or ( (high - low) < adr_val * 2.5 )
    
    // 0c. Volatility Filter (Avoid Choppy Markets)
    min_vol_confirm = atr_val_14 > ta.sma(atr_val_14, 100) * 0.5
    
    // 0b. Daily Loss Protection (Now Global)
    // loss_confirm is used directly from the global scope
    if show_signals
        // ULTRA FIX: Use Internal Trend if enabled for faster entries
        bool is_buy_trend = use_internal_trend ? internalTrend.bias == BULLISH : swingTrend.bias == BULLISH
        bool is_sell_trend = use_internal_trend ? internalTrend.bias == BEARISH : swingTrend.bias == BEARISH
        
        // 0. Daily Trend Alignment (Select Filter)
        d_align = not use_daily_align or (is_buy_trend and d_close > d_trend_val) or (is_sell_trend and d_close < d_trend_val)
        
        // üÜï MOMENTUM EXCEPTION (Catch Strong Trends)
        // If ADX is high (>25), we assume strong momentum and ignore the "Deep Discount" rule.
        [di_plus, di_minus, adx_val] = ta.dmi(14, 14)
        has_momentum = adx_val > 25

        // 0b. PD Filter (ULTRA) - Relaxed to 60%
        // If Momentum is strong, we allow buying in the "Grey Zone" (40%) or even slightly Premium.
        
        float pd_limit_buy = (is_forex or is_gold) ? 0.60 : 0.45  // ULTRA: 0.60 (60% du range)
        float pd_limit_sell = (is_forex or is_gold) ? 0.40 : 0.55  // ULTRA: 0.40 (40% du range)
        
        if has_momentum
            pd_limit_buy  := 0.70  // Allow buying up to 70% of range (shallow pullback)
            pd_limit_sell := 0.30  // Allow selling down to 30% of range (shallow pullback up)

        buy_zone_limit  = trailing.bottom + (trailing.top - trailing.bottom) * pd_limit_buy
        sell_zone_limit = trailing.bottom + (trailing.top - trailing.bottom) * pd_limit_sell

        pd_confirm = not use_pd_filter or (is_buy_trend and close <= buy_zone_limit) or (is_sell_trend and close >= sell_zone_limit)


        // 0c. Liquidity Sweep Check (Last 10 bars)
        s_sw = 5
        ph_s = ta.pivothigh(high, s_sw, s_sw)
        pl_s = ta.pivotlow(low, s_sw, s_sw)
        var float last_ph = na
        var float last_pl = na
        if not na(ph_s)
            last_ph := ph_s
        if not na(pl_s)
            last_pl := pl_s
        
        sweep_high = high > last_ph and close < last_ph
        sweep_low  = low < last_pl and close > last_pl
        
        bool has_sweep = not use_sweep_conf or (is_buy_trend and ta.barssince(sweep_low) < 30) or (is_sell_trend and ta.barssince(sweep_high) < 30)

        // 1. MTF Filter
        bool mtf_confirm = not use_mtf_filter or (is_buy_trend and htf_bias == BULLISH) or (is_sell_trend and htf_bias == BEARISH)
        
        // üÜï 2. WEEKLY FILTER (TOP-DOWN APPROACH - Most Important)
        // This is the foundation: Never trade against the Weekly trend
        // Institutions trade from macro to micro, we do the same
        bool weekly_confirm = not use_weekly_filter or 
                              (is_buy_trend and w_trend == BULLISH) or 
                              (is_sell_trend and w_trend == BEARISH)
        
        // 3. SMT Filter (Divergence check)
        bool smt_confirm = not use_smt_filter or (is_buy_trend and smt_bias == BULLISH) or (is_sell_trend and smt_bias == BEARISH)
        
        // 3. BOS Strength Filter
        bool bos_confirm = not use_bos_filter or bos_str >= bos_threshold
        
        // 4. Volume Confirmation (Smart Adjustment)
        avg_vol = ta.sma(volume, 14)
        high_vol = not use_vol_filter or (volume >= avg_vol * vol_mult) // ULTRA FIX: Force vol_mult input
        
        // 5. Candle Confirmation (Anti-Fakeout for Forex & GOLD)
        // Gold needs confirmation to avoid "catching knives" during high volatility
        need_conf   = is_forex or is_gold
        candle_conf = not need_conf or (is_buy_trend ? close > open : close < open)
        
        // 6. JPY Special Rejection (Wick > 15% - Relaxed)
        wick_size = is_buy_trend ? (close - low) : (high - close)
        full_size = high - low
        jpy_rej_conf = not is_jpy or (full_size > 0 and wick_size / full_size > 0.15)
        
        // 7. JPY Asian Range Filter (Trade in the direction of the break)
        jpy_asian_conf = not is_jpy or na(asian_h) or (is_buy_trend ? close > asian_h : close < asian_l)
        

        // üõ°Ô∏è DYNAMIC BUFFER CALCULATION (ATR BASED)
        // Allows price to just graze the zone or miss it slightly (Front-run protection)
        fuzz_val = atr_val_14 * mitigation_buffer_atr

        // Detection Mitigation OB (With Buffer)
        bool touch_bull_ob = false
        bool touch_bear_ob = false
        float ob_sl = na
        
        // Check Bullish OBs
        if swingOrderBlocks.size() > 0
            for ob in swingOrderBlocks
                // Logic: Low is low enough to be inside OR near the top of OB (within buffer)
                if ob.bias == BULLISH and low <= (ob.barHigh + fuzz_val) and low >= (ob.barLow - fuzz_val)
                    touch_bull_ob := true
                    ob_sl := ob.barLow
                    sig_ent := ob.barHigh - (ob.barHigh - ob.barLow) * (is_jpy ? 0.20 : 0.25) 
                    break
        
        // Check Bearish OBs
        if swingOrderBlocks.size() > 0
            for ob in swingOrderBlocks
                // Logic: High is high enough to be inside OR near the bottom of OB (within buffer)
                if ob.bias == BEARISH and high >= (ob.barLow - fuzz_val) and high <= (ob.barHigh + fuzz_val)
                    touch_bear_ob := true
                    ob_sl := ob.barHigh
                    sig_ent := ob.barLow + (ob.barHigh - ob.barLow) * (is_jpy ? 0.20 : 0.25)
                    break
        
        // Check Internal Order Blocks (More frequent)
        bool touch_bull_iob = false
        bool touch_bear_iob = false
        if internalOrderBlocks.size() > 0
            for ob in internalOrderBlocks
                if ob.bias == BULLISH and low <= (ob.barHigh + fuzz_val) and low >= (ob.barLow - fuzz_val)
                    touch_bull_iob := true
                    ob_sl := na(ob_sl) ? ob.barLow : math.min(ob_sl, ob.barLow)
                    sig_ent := ob.barHigh
                    break
            for ob in internalOrderBlocks
                if ob.bias == BEARISH and high >= (ob.barLow - fuzz_val) and high <= (ob.barHigh + fuzz_val)
                    touch_bear_iob := true
                    ob_sl := na(ob_sl) ? ob.barHigh : math.max(ob_sl, ob.barHigh)
                    sig_ent := ob.barLow
                    break

        // Detection Mitigation FVG (With Buffer)
        bool touch_bull_fvg = false
        bool touch_bear_fvg = false
        if fairValueGaps.size() > 0 // ULTRA FIX: Always check FVG even if input disabled visually
            for fvg in fairValueGaps
                if fvg.bias == BULLISH and low <= (fvg.top + fuzz_val) and low >= (fvg.bottom - fuzz_val)
                    touch_bull_fvg := true
                    ob_sl := na(ob_sl) ? fvg.bottom : math.min(ob_sl, fvg.bottom)
                    break
                if fvg.bias == BEARISH and high >= (fvg.bottom - fuzz_val) and high <= (fvg.top + fuzz_val)
                    touch_bear_fvg := true
                    ob_sl := na(ob_sl) ? fvg.top : math.max(ob_sl, fvg.top)
                    break


        // SIGNAL BUY (Dynamic Confluence)
        // ULTRA FIX: Allow Swing OB OR Internal OB OR FVG
        buy_conf = touch_bull_ob or touch_bull_iob or touch_bull_fvg
        if is_buy_trend and buy_conf and mtf_confirm and weekly_confirm and smt_confirm and (bos_str >= bos_threshold) and high_vol and is_kz and d_align and pd_confirm and has_sweep and adr_confirm and loss_confirm and candle_conf // TOP-DOWN: Added weekly_confirm
            if new_dir != 1
                entry_p = na(sig_ent) ? close : sig_ent
                // Gold Volatility Protection: Wider SL Padding (1.5 ATR)
                padding_value = (is_gold ? 1.5 : sl_padding_atr) * atr_val_14
                sl = math.min(ob_sl - padding_value, entry_p - ((is_jpy ? 1.2 : 1.0) * atr_val_14))
                risk_in_price = math.max(entry_p - sl, syminfo.mintick)
                tp = entry_p + (risk_in_price * rr_ratio)
                
                txt = "BUY"
                if use_rm_labels
                    txt := "BUY" // Simplified label
                
                // CLEANUP OLD LABELS
                var label last_buy_label = na
                if not na(last_buy_label)
                    label.delete(last_buy_label)

                if barstate.isconfirmed
                    var label lb_buy = na
                    label.delete(lb_buy)
                    lb_buy := label.new(bar_index, low, txt, color=GREEN, style=label.style_label_up, textcolor=color.white, size=sig_size)
                    
                    // Logic Position Sizing (Universal 1% Risk Formula)
                    risk_usd_per_unit = risk_in_price / (is_jpy ? close : 1.0)
                    pos_size = risk_usd_per_unit > 0 ? (strategy.equity * (risk_per_trade / 100)) / risk_usd_per_unit : 0
                    
                    strategy.entry("Long", strategy.long, qty=pos_size)
                    strategy.exit("Exit Long", "Long", stop=sl, limit=tp)
                    
                    sig_sl  := sl
                    sig_ent := close
                    new_dir := 1

        // SIGNAL SELL (Dynamic Confluence)
        sell_conf = touch_bear_ob or touch_bear_iob or touch_bear_fvg
        if is_sell_trend and sell_conf and mtf_confirm and weekly_confirm and smt_confirm and (bos_str >= bos_threshold) and high_vol and is_kz and d_align and pd_confirm and has_sweep and adr_confirm and loss_confirm and candle_conf // TOP-DOWN: Added weekly_confirm
            if new_dir != -1
                // Dynamic ATR Padding (Wider for Gold)
                padding_value = (is_gold ? 1.5 : sl_padding_atr) * atr_val_14
                sl = math.max(ob_sl + padding_value, close + (1.2 * atr_val_14))
                risk_in_price = math.max(sl - close, syminfo.mintick)
                tp = close - (risk_in_price * rr_ratio)
                
                txt = "SELL"
                if use_rm_labels
                    txt := "SELL" // Simplified label
                
                // CLEANUP OLD LABELS
                var label last_sell_label = na
                if not na(last_sell_label)
                    label.delete(last_sell_label)

                if barstate.isconfirmed
                    var label lb_sell = na
                    label.delete(lb_sell)
                    lb_sell := label.new(bar_index, high, txt, color=RED, style=label.style_label_down, textcolor=color.white, size=sig_size)
                    
                    // Logic Position Sizing (Universal 1% Risk Formula)
                    risk_usd_per_unit = risk_in_price / (is_jpy ? close : 1.0)
                    pos_size = risk_usd_per_unit > 0 ? (strategy.equity * (risk_per_trade / 100)) / risk_usd_per_unit : 0
                    
                    strategy.entry("Short", strategy.short, qty=pos_size)
                    strategy.exit("Exit Short", "Short", stop=sl, limit=tp)
                    
                    sig_sl  := sl
                    sig_ent := close
                    new_dir := -1
    
    [new_dir, sig_sl, sig_ent] // Retourner la nouvelle valeur + infos du trade

//---------------------------------------------------------------------------------------------------------------------}
// EXECUTION
//---------------------------------------------------------------------------------------------------------------------{
parsedOpen  = showTrendInput ? open : na
candleColor = internalTrend.bias == BULLISH ? swingBullishColor : swingBearishColor
// plotcandle(parsedOpen,high,low,close,color = candleColor, wickcolor = candleColor, bordercolor = candleColor)

// Main Flow
updateTrailingExtremes()
getCurrentStructure(swingsLengthInput,false)
getCurrentStructure(5,false,true)

if showEqualHighsLowsInput
    getCurrentStructure(equalHighsLowsLengthInput,true)

if showInternalsInput or showInternalOrderBlocksInput or showTrendInput
    displayStructure(true)

if showStructureInput or showSwingOrderBlocksInput or showHighLowSwingsInput
    displayStructure()

if showInternalOrderBlocksInput
    deleteOrderBlocks(true)

if showSwingOrderBlocksInput
    deleteOrderBlocks()

if showFairValueGapsInput
    drawFairValueGaps()

// üí• Breaker Blocks Detection & Drawing
if show_breakers
    detectBreakers()


if showHighLowSwingsInput
    drawHighLowSwings()

if barstate.islastconfirmedhistory or barstate.islast
    if showInternalOrderBlocksInput        
        drawOrderBlocks(true)
    if showSwingOrderBlocksInput        
        drawOrderBlocks()
    if show_breakers
        drawBreakers()
    
    if showDailyLevelsInput and not higherTimeframe('D')
        drawLevels('D',timeframe.isdaily,dailyLevelsStyleInput,dailyLevelsColorInput)

    if showWeeklyLevelsInput and not higherTimeframe('W')
        drawLevels('W',timeframe.isweekly,weeklyLevelsStyleInput,weeklyLevelsColorInput)

    if showMonthlyLevelsInput and not higherTimeframe('M')
        drawLevels('M',timeframe.ismonthly,monthlyLevelsStyleInput,monthlyLevelsColorInput)

// üéØ Signals
[s_dir, s_sl, s_ent] = checkSignals()
last_signal_dir := s_dir

// Display Big Alert (LIVE)
displaySignalDash()

// üõ°Ô∏è BREAK-EVEN & PARTIAL TP LOGIC
// Fix: We rely on strategy.position_size changes to reset state, not just signal presence
var float last_pos_sign = 0.0
if math.sign(strategy.position_size) != last_pos_sign
    partial_done := false
    last_pos_sign := math.sign(strategy.position_size)

if not na(s_sl)
    trade_sl := s_sl
if not na(s_ent) and strategy.position_size == 0 // Only update entry price if we are flat (new trade)
    trade_ent := s_ent

if strategy.position_size != 0 and not na(trade_sl) and not na(trade_ent)
    risk = math.abs(trade_ent - trade_sl)
    
    // 1. Partial Take Profit (30% pour laisser courir le profit final)
    if use_partial_tp and not partial_done
        if strategy.position_size > 0 and high >= trade_ent + (risk * partial_rr)
            strategy.close("Long", qty_percent=30, comment="Secure 30%")
            partial_done := true
        if strategy.position_size < 0 and low <= trade_ent - (risk * partial_rr)
            strategy.close("Short", qty_percent=30, comment="Secure 30%")
            partial_done := true

    // 2. Break-Even (Smart Cover)
    // Moves SL slightly past entry to cover swap/commissions
    if use_be
        be_offset = 0.1 * atr_val_14_global 
        if strategy.position_size > 0 and high >= trade_ent + (risk * be_target)
            strategy.exit("BE Long", "Long", stop=trade_ent + be_offset, comment="SL Breakeven+")
        if strategy.position_size < 0 and low <= trade_ent - (risk * be_target)
            strategy.exit("BE Short", "Short", stop=trade_ent - be_offset, comment="SL Breakeven+")


if strategy.position_size == 0
    partial_done := false

lastBarIndex    := currentBarIndex
currentBarIndex := bar_index
newBar          = currentBarIndex != lastBarIndex

//---------------------------------------------------------------------------------------------------------------------}
